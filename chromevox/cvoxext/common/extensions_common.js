// Copyright 2012 Google Inc. All Rights Reserved.

/* @fileoverview Chromevox extension framework
 * A common framework which makes it easier to write page-specific
 * extensions for Chromevox to enhance UX
 * Components:
 * util: a group of convenience functions which makes it easy to
 *       manage DOM objects
 * speakable: an object which is created in a way chromevox can
 * understand and read properly.
 * speakableManager: library to manage speakables.
 * @author cagriy@google.com (Cagri Yildirim)
 *
 */

cvoxExt = {}; //define pseudo-namespace

/**----------------------------------------------------------------------*/

/**
 * each speakable has a type string, a CSS class selector to
 * identify the object, an associative array of objs for its subelements,
 * and a boolean to tell whether the type is going to be read.
 * @constructor
 * @this {speakable}
 * @param {string} element CSS selector for the speakable type.
 * @param {Object<string, string>} subselectors associative array storing
       CSS selectors of the child elements that will be spoken.
 * @param {string} type type of speakable.
 * @param {string} opt_extraText extra text to be read with the object.
 * @param {boolean} opt_readTextContent should read the text content of node.
 */
cvoxExt.speakable = function(element, subselectors,
      type, opt_extraText, opt_readTextContent) {

  this.obj = element;
  this.subselectors = subselectors;
  this.type = type;
  this.opt_extraText = opt_extraText;
  this.opt_readTextContent = opt_readTextContent;
};

/** @const subselector types to classify in node descriptions */
cvoxExt.speakable.subselectorTypes = {
  CONTEXT: 'context',
  USER_VALUE: 'userValue',
  ANNOTATION: 'annotation',
  TEXT: 'text'
};

/**
 * create node description object from DOM object of a speakable type.
 * every speakable has an array of subselectors which describes the speakable,
 * to generate the speech
 * propreties of a subselector:
   -pretext: a text to be read before string
   -posttext: a text to be read after string
   -type: type for node description (user value, annotation, etc.)
   -splitterFunction: a function that will appropriately split the string
     selected by the selector and will create an array classifiying the strings
     to their appropriate types.
   -text: (created dynamically) the text to be read
 * @param {Object} domObj DOM object.
 * @this {speakable}
 * @return {Array<cvox.NodeDescription>} array of
       node description of the DOM object.
 */
cvoxExt.speakable.prototype.generateSpeechNode = function(domObj) {
  var nodeDescs = new Array();
  if (this.opt_extraText) {
    var text = this.opt_extraText;
  } else {
    text = '';
  }
  if (this.opt_readTextContent) {
    text += domObj.textContent;
  }
  var context = '';
  var userValue = '';
  var annotation = '';

  var subselectors = this.subselectors;
  var addNode = function(nodeName) {
    var subselector = subselectors[nodeName];
    subselector.text = '';
    // Each subselector may be composed of an array of speakables,
    // in which case chromevox will attempt to read the child
    // speakables in the parameter object.
    var childSpeakables = subselector.speakables;
    if (childSpeakables) {
      for (var i = 0; i < childSpeakables.length; ++i) {
        var nodes = util.getDomObjectsFromSelector(
            childSpeakables[i].obj, domObj);
        for (var j = 0; j < nodes.length; ++j) {
          var childNodeDesc = childSpeakables[i].generateSpeechNode(
            nodes[j]);
          arrayAddAll(nodeDescs, childNodeDesc);
          //recursively add all node description arrays generated by
          //children
        }
      }
    }

    //Additionally a subselector object might have a type
    //to point out which type of data it is, or it might be
    //just a string, in which case everything is added as regular
    //text, and a attribute to point out which attribute to read
    //from node

    // An attribute of the subselector maybe read in lieu of the
    // node text content
    if (subselector.attribute) {
      var attribute = domObj.getAttribute(subselector.attribute);
      if (attribute) {
        subselector.text = attribute;
      }
    }
    else {
      var node = util.getFirstDomObjectFromSelector(
            subselector.selector, domObj);
      if (node) {
        // Each subselector may come with a pre-text and post-text which will be
        // read before or after the selector
        if (subselector.pretext) {
          subselector.text += subselector.pretext;
        }
        //shall read text content
        if (node.textContent) {
          subselector.text += node.textContent;
        }
      }
    }
    var subselectorArray = [];
    //A splitter function maybe written for a given subselector to
    // split and fine-tune each string's type
    /* eg: function splitterFunction(dateAndCircle) {
             var splitStrArr = dateAndCircle.split(' ');
             subselectorArray[0].text = splitStrArr[0]; //date
             subselectorArray[0].type =
                 cvoxExt.speakable.subselectorTypes.USER_VALUE
             subselectorArray[1].text = splitStrArr[1]; //circle
             subselectorArray[1].type =
                 cvoxExt.speakable.subselectorTypes.ANNOTATION;
       }
    */
    if (subselector.splitterFunction) {
      subselectorArray = subselector.splitterFunction(subselector.text);
    }
    else {
      subselectorArray.push(subselector);
    }
    for (var i = 0; i < subselectorArray.length; ++i) {
      if (!subselectorArray[i].type) {
        subselectorArray[i].type =
            cvoxExt.speakable.subselectorTypes.TEXT;
      } //default to text
      switch (subselectorArray[i].type) {
        case cvoxExt.speakable.subselectorTypes.CONTEXT:
          context += '.\n' + subselectorArray[i].text;
          break;
        case cvoxExt.speakable.subselectorTypes.USER_VALUE:
          userValue += '.\n' + subselectorArray[i].text;
          break;
        case cvoxExt.speakable.subselectorTypes.ANNOTATION:
          annotation += '.\n' + subselectorArray[i].text;
          break;
        default:
          text += '.\n' + subselectorArray[i].text;
          break;
      }
    }
    if (subselector.posttext) {
      text += subselector.posttext;
    }
  }
  for (obj in subselectors) {
     addNode(obj);
  }
  nodeDescs.push(
      new cvox.NodeDescription(context, text, userValue, annotation));
  return nodeDescs;
};

/**
 * each speakable has a type string, a DOM obj (or a CSS selector
 * pointing to that object),
 * an associative array of objs for its subelements,
 * and a boolean to tell whether the type is going to be read.
 * @constructor
 * @this {cvoxExt.speakableInIframe}
 * @param {string} element DOM Element or CSS selector for the speakable type.
 * @param {Object<string, string>} subselectors associative array storing
       CSS objs of the child elements that will be spoken.
 * @param {string} type type of speakable.
 * @param {string} opt_extraText extra text to be read with the object.
 * @param {boolean} opt_readTextContent should read the text content of node.
 */
cvoxExt.speakableInIframe = function(element, subselectors,
      type, opt_extraText, opt_readTextContent) {

  this.obj = element;
  this.subselectors = subselectors;
  this.type = type;
  this.opt_extraText = opt_extraText;
  this.opt_readTextContent = opt_readTextContent;
};

/** speakable object in iframe */
cvoxExt.speakableInIframe.prototype = new cvoxExt.speakable();

/** get the iframe of the speakable in iframe
 *  @return {Object} iframe of speakable.
 */
cvoxExt.speakableInIframe.prototype.getFrame = function() {
  return util.getFirstDomObjectFromSelector(this.frame);
};

/**----------------------------------------------------------------------*/

cvoxExt.speakableManager = {};
var speakableManager = cvoxExt.speakableManager;

/** key to switch to next speakable
 */
speakableManager.speakableNextKey = null;

/** key to switch to previous speakable
 */
speakableManager.speakablePrevKey = null;

/** key to switch to next element of
 * current speakable, switch to null
 * to disable
 */
speakableManager.elementNextKey = null;

/** key to switch to prev element of
 * current speakable, switch to null
 * to disable
 */
speakableManager.elementPrevKey = null;

/** should read focus */
speakableManager.readFocus = true;

/** reassignment */
cvoxExt.readFocus = speakableManager.readFocus;

/** set key to switch speakable
 *  @param {String} key key to switch to.
 *  @param {boolean} next is it the next or prev.
 */
speakableManager.setSpeakableSwitchKey = function(key, next) {
  if (next) {
    speakableManager.speakableNextKey = key;
  } else {
    speakableManager.speakablePrevKey = key;
  }
};

/** disable keyboard shortcuts for extension managed traversal */
speakableManager.disableManagedTraversal = function() {
  cvoxExt.speakableManager.elementNextKey = null;
  cvoxExt.speakableManager.elementPrevKey = null;
  cvoxExt.speakableManager.speakableNextKey = null;
  cvoxExt.speakableManager.speakablePrevKey = null;
};

/** enable default keyboard shortcuts for extension
   managed traversal */
speakableManager.enableDefaultManagedTraversal = function() {
  cvoxExt.speakableManager.elementNextKey = 'j';
  cvoxExt.speakableManager.elementPrevKey = 'k';
  cvoxExt.speakableManager.speakableNextKey = 'n';
  cvoxExt.speakableManager.speakablePrevKey = 'p';
};

/**
 * map of speakable types to speakables
 * example: speakableManager.speakables ['thread'] => speakable representation
 * of a gPlus thread
 */
speakableManager.speakables = {};

/**
 * map of CSS selectors to speakable types
 * example: speakableManager['.lp.gx] => 'comment'
 */
speakableManager.selectorToType = {};

/**
 * map of speakable to their key listeners
 */
speakableManager.speakableToKeyFunction = {};

/**
 * the order which speakables are traversed.
 */
speakableManager.orderedSpeakables = [];

/**
 * pointer to current speakable
 */
speakableManager.currSpeakable = 0;

/**
 * index of element of current speakable
 */
speakableManager.currElementOfSpeakable = 0;

/**
 * adds object pointed by CSS selector to the speakables
 * useful for pages which have auto shortcuts that traverse
 * the page and with no manual need differentiate CSS selectors.
 * @param {string} selector CSS selector of object.
 * @param {string} type speakable type.
 */
speakableManager.addSelector = function(selector, type) {
  speakableManager.selectorToType[selector] = type;
};

/**
 * adds a constructed speakable object
 * the object could have been passed in as a CSS selector or
 * as a specific object, if a selector is not enough to differentiate
 * the object.
 * @param {cvoxExt.speakable} speakable speakable representation of object.
 */
speakableManager.addSpeakable = function(speakable) {
  if (!speakableManager.speakables[speakable.type] && speakable.obj) {
      speakableManager.addSelector(speakable.obj, speakable.type);
  }
  speakableManager.speakables[speakable.type] = speakable;
  speakableManager.orderedSpeakables.push(speakable);
};

/**
 * adds a constructed speakable object as hidden object.
 * a hidden object is not added to ordered speakables array, therefore cannot
 * be directly traversed, however the extension will remember it when it is
 * focused. This is useful in websites which have their own focusing systems
 * already implemented.
 * For example in Gmailvox, since Gmail provides the GMonkey API to adapt
 * its own focusing system, we can override the generateSpeechNode for the
 * speakable denoting each message and add that as a hidden speakable.
 * cvoxExt will not focus to each message, rather will provide guidance
 * how each message is read when it is focused by Gmonkey.
 *
 * @param {cvoxExt.speakable} speakable speakable representation of object.
 */
speakableManager.addNoTraverseSpeakable = function(speakable) {
  if (!speakableManager.speakables[speakable.type] && speakable.obj) {
      speakableManager.addSelector(speakable.obj, speakable.type);
  }
  speakable.hidden = true;
  speakableManager.speakables[speakable.type] = speakable;
};

/**
 * update the order of speakables according to which elements are visible
 */
speakableManager.updateSpeakables = function() {
  speakableManager.orderedSpeakables = [];
  for (var i in speakableManager.speakables) {
      speakableManager.speakables[i].visible = false;
    if (!speakableManager.speakables[i].hidden) {
      speakableManager.orderedSpeakables.push(speakableManager.speakables[i]);
    }
  }
  speakableManager.orderedSpeakables = cvoxExt.util.whichOnesVisible(
     speakableManager.orderedSpeakables);
  for (var i = 0; i < speakableManager.orderedSpeakables.length; ++i) {
    var speakable = speakableManager.speakables[speakableManager.
        orderedSpeakables[i].type];
    speakable.visible = true;
    speakable.index = i;
  }

};

/** resets all speakables */
speakableManager.clearSpeakables = function() {
  speakableManager.speakables = {};
  speakableManager.orderedSpeakables = [];
  speakableManager.currSpeakable = 0;
};

/**
 * finds the speakable of a given CSS selector name
 * only needed for speakables that have been added by their selector names.
 * @param {HTMLElement} target target DOM object.
 * @return {speakableManager.speakable} speakable of the class name.
 */
speakableManager.adaptSpeakableToObject = function(target) {
  console.log(target);
  var classnames = new Array();
  if (target.getAttribute) {
    var type = target.getAttribute('speakableType');
    if (type) {
      return speakableManager.speakables[type];
    }
  } else if (target.speakableType) {
    return speakableManager.speakables[target.speakableType];
  }
  var targetClassName = target.className;
  //try class names, a speakable must have all its class names matched,
  //but not all class names of the element must be matched by a speakable
  var pieces = targetClassName.split(' ');
  var possibleSelector = '.' + pieces.join('.');
  var possibleType = speakableManager.selectorToType[possibleSelector];
  if (possibleType) {
    return speakableManager.speakables[possibleType];
  } else {
    var maxMatched = ''; //the most matched wins
    for (var selector in speakableManager.selectorToType) {

      var selectorPossible = true;
      var splitSelectors = selector.split('.').slice(1);
      for (var i = 0; i < splitSelectors.length; ++i) {
        if (pieces.indexOf(splitSelectors[i]) == -1) {
           selectorPossible = false;
           break;
        }
      }
      //exclude certain class names
      if (selector.split('.').length > 1) {
        var excRules = speakableManager.speakables[
            speakableManager.selectorToType[selector]].exclude;
        console.log(selector);
        if (excRules) {
          for (var i = 0; i < excRules.length; ++i) {
            console.log(pieces);
            if (excRules[i].charAt(0) == '.') {
              excRules[i] = excRules[i].slice(1);
              // strip the dot in start if needed
            }
            if (pieces.indexOf(excRules[i] == 0)) {
              selectorPossible = false;
              var selectorExcluded = true;
              break;
            }
          }
        }
      }
      if (selectorPossible) {
        maxMatched = (maxMatched == '' && selector) ||
            maxMatched.split('.').length < selector.split('.').length ?
            selector : maxMatched;
      }
    }
  }
  if (maxMatched != '') {
    speakableManager.selectorToType[possibleSelector] =
        speakableManager.selectorToType[maxMatched];
    return speakableManager.speakables[speakableManager.
        selectorToType[maxMatched]];
  }
};

/**
 * updates speech nodes of elements that benefit from the
 * written extension by adapting target to a speakable.
 * @param {Object} target target DOM object.
 */
speakableManager.updateSpeak = function(target) {
  var speakable = speakableManager.adaptSpeakableToObject(target);
  console.log(speakable);
  if (!speakable) { return; } //return if could not find appropriate speak
  var speechNodeDescs = speakable.generateSpeechNode(target);
  console.log(speechNodeDescs);
  if (speakable.getFrame && speakable.getFrame()) {
    speakable.getFrame().contentWindow.cvox.Api.setSpeechForNode(
      target, speechNodeDescs);
  } else if (target.setAttribute) {
    cvox.Api.setSpeechForNode(target, speechNodeDescs);
  }
};

/**
 * adds a keyboard shortcut which only works when a given speakable object
 * is focused.
 * @param {speakableManager.speakable} speakable the speakable
    with which the shortcut is associated.
 * @param {String} key key of shortcut.
 * @param {function} functionToImplement to be run on keypress.
 */
speakableManager.addSpeakableKeyListener = function(speakable, key, 
     functionToImplement) {
  //make sure keyboard shortcuts do not conflict with chromevox shortcuts
  if (!speakableManager.speakableToKeyFunction[speakable.type]) {
    speakableManager.speakableToKeyFunction[speakable.type] = new Object();
  }
  speakableManager.speakableToKeyFunction[speakable.type][key] =
      functionToImplement;
};

/**
 * moves to the next speakable
 * @param {Number} next the index of speakable to move to.
 */
speakableManager.nextSpeakable = function(next) {
  if (cvoxExt.iframeUtil.frameType == 'child') {
    parent.focus();
    return;
  }
  cvox.Api.stop();
  speakableManager.currElementOfSpeakable = 0;
  if (speakableManager.orderedSpeakables.length != 0) {
    speakableManager.currSpeakable = next;
    if (speakableManager.currSpeakable >=
        speakableManager.orderedSpeakables.length) {
       speakableManager.currSpeakable = 0;
    } else if (speakableManager.currSpeakable < 0) {
      speakableManager.currSpeakable =
        speakableManager.orderedSpeakables.length - 1;
    }

    var nextSpeakable =
        speakableManager.orderedSpeakables[speakableManager.currSpeakable];
    if (nextSpeakable.getFrame && nextSpeakable.getFrame()) {
      nextSpeakable.getFrame().focus();
    }

    var obj = util.whichOnesVisible(
        util.getDomObjectsFromSelector(nextSpeakable))[0];
    obj.setAttribute('tabindex', -1);//to allow focus
    speakableManager.nextElementOfCurrSpeakable(0);
  }
};

/** gets the next speakable object by speakable type
 * @param {string} type type string of speakable.
*/
speakableManager.nextSpeakableByType = function(type) {
  speakableManager.nextSpeakable(speakableManager.
     orderedSpeakables.indexOf(speakableManager.speakables[type]));
};

/** go to the next element in the current speakable
 * @param {number} next element's index.
 */

speakableManager.nextElementOfCurrSpeakable = function(next) {
  if (cvoxExt.iframeUtil.frameType == 'child') {
    parent.focus();
    return;
  }
  speakableManager.currElementOfSpeakable = next;
  var currSpeakable =
    speakableManager.orderedSpeakables[speakableManager.currSpeakable];
  var elements = util.whichOnesVisible(
                util.getDomObjectsFromSelector(currSpeakable));
  if (speakableManager.currElementOfSpeakable >= elements.length) {
    speakableManager.currElementOfSpeakable = 0;
  } else if (speakableManager.currElementOfSpeakable < 0) {
   speakableManager.currElementOfSpeakable = elements.length - 1;
  }
  var newFocus = elements[speakableManager.currElementOfSpeakable];
  if (newFocus) {
    if (currSpeakable.getFrame && currSpeakable.getFrame()) {
      currSpeakable.getFrame().cvox.Api.syncToNode(newFocus);
      currSpeakable.getFrame().focus();
    } else {
      window.focus();
      cvox.Api.syncToNode(newFocus);
    }
    newFocus.setAttribute('tabindex', speakableManager.currElementOfSpeakable);
    newFocus.focus();
    speakableManager.focusedElement = newFocus;
  }
};

/** updates speak node description when an object is focused
 * no need to update current element of speakable because website
 * already has a mechanism to traverse between each element
 * @param {event} evt DOM event.
 */
speakableManager.checkIfSpeakableFocused = function(evt) {
  if (cvoxExt.readFocus) {
    if (cvoxExt.iframeUtil.frameType == 'child') {
      parent.cvoxExt.speakableManager.checkIfSpeakableFocused(evt);
      return;
    }
    var message = speakableManager.frameId;
    speakableManager.updateSpeak(evt.target);
  }
};

/** switches to the next speakable if the speakable key is pressed
 * implements addSpeakableKeyListener functionality
 * @param {event} evt DOM event.
 * @return {boolean} event suppressor.
 */
speakableManager.keyHandler = function(evt) {
  if (cvoxExt.iframeUtil.frameType == 'child') {
    parent.speakableManager.keyHandler(evt);
    return false;
  }
  speakableManager.updateSpeakables();
  //TODO make a more robust check for inputtable elements
  if (document.activeElement.tagName == 'INPUT') {
    return true;
  }
  var orderedSpeakables = speakableManager.orderedSpeakables;
  var currSpeakable = speakableManager.currSpeakable;
  var speakableKeyToFunction = speakableManager.speakableToKeyFunction;
  if (!orderedSpeakables[currSpeakable]) {return;}
  var keyToFunction =
     speakableKeyToFunction[orderedSpeakables[currSpeakable].type];
  if (keyToFunction) {
    var func = keyToFunction[String.fromCharCode(evt.charCode)];
    if (func) {
      func();
      evt.stopPropagation();
      return false;
    }
  }

  if (speakableManager.speakableNextKey && evt.charCode ==
      speakableManager.speakableNextKey.charCodeAt(0)) {
    speakableManager.nextSpeakable(speakableManager.currSpeakable + 1);
    evt.stopPropagation();
    return false;
  } else if (speakableManager.speakablePrevKey && evt.charCode ==
      speakableManager.speakablePrevKey.charCodeAt(0)) {
    speakableManager.nextSpeakable(speakableManager.currSpeakable - 1);
    evt.stopPropagation();
    return false;
  } else if (speakableManager.elementNextKey && evt.charCode ==
      speakableManager.elementNextKey.charCodeAt(0)) {
    speakableManager.nextElementOfCurrSpeakable(
        speakableManager.currElementOfSpeakable + 1);
    evt.stopPropagation();
    return false;
  } else if (speakableManager.elementPrevKey && evt.charCode ==
      speakableManager.elementPrevKey.charCodeAt(0)) {
    speakableManager.nextElementOfCurrSpeakable(
        speakableManager.currElementOfSpeakable - 1);
    evt.stopPropagation();
    return false;
  }
  return true;
};


/** focus on the first page on load
*/
speakableManager.focusFirstElementOnLoad = function() {
  speakableManager.nextElement(0);
  speakableManager.nextElementOfCurrSpeakable(0);
};

/** update speakables on load
*/
speakableManager.updateSpeakablesOnLoad = function() {
  speakableManager.updateSpeakables();
};

/**-----------------------------------------------------------------------*/

cvoxExt.util = {}; //define pseudo-namespace

var util = cvoxExt.util; //alias namespace

/**
 * map of special keys to their keycodes
 * @const
 */
util.KEY_CODES = {
  'bs' : 8,
  'tab' : 9,
  'return' : 13,
  'shift': 16,
  'ctrl': 17,
  'alt': 18,
  'home': 36,
  'up': 38,
  'left': 37,
  'right': 39,
  'down': 40
};

/**
 * @param {String} key key of shortcut.
 * @param {function} functionToImplement the function
     that will be run when key is pressed.
 */
util.addKeyboardShortcut = function(key, functionToImplement)  {
  //TODO make sure keyboard shortcuts do not conflict with chromevox shortcuts
  var keyboardListener = function(evt) {
    //making sure that the element is not an input field
    if (!document.activeElement.form && (evt.charCode == keyCodes[key] ||
       key == String.fromCharCode(evt.charCode))) {
      functionToImplement();
    }
  };
  document.addEventListener('keypress', keyboardListener);
};

/**
 * @param {String} key key of shortcut.
 * @param {Object} obj object to click on shortcut
     that will be run when key is pressed.
 */
util.addClickShortcut = function(key, obj) {
  var clickObj = function() {
    cvox.Api.click(cvoxExt.getFirstDomObjectFromSelector(obj));
  }
  util.addKeyboardShortcut(key, clickObj);
};


/**
 * Returns the first DOM object of the selector
 * @param {String|HTMLElement|cvoxExt.speakable} selector CSS selector.
 * @param {Object} opt_target optional target to select from.
 * @return {Element} DOM element of selector.
 */
util.getFirstDomObjectFromSelector = function(selector, opt_target) {
  return util.getDomObjectsFromSelector(selector, opt_target)[0];
};

/**
 * a utilty function which gets the visibles DOM object from
 * its selector which could be any type, such as tag or
 * class name or even the object itself
 * @param {Object} selector the selector of object.
 * @param {HTMLElement} opt_target a target element such as div to
 * select the object from (optional).
 * @return {Object} the html elements of the selector.
 */
util.getDomObjectsFromSelector = function(selector, opt_target) {
  var target = document;
  if (opt_target) {
    target = opt_target;
  }
  if (!selector) {
    return [];
  }
  if (selector.ownerDocument) {
    return [selector];
  } else if (selector.obj) {
    if (selector.getFrame && selector.getFrame()) {
      return util.getDomObjectsFromSelector(selector.obj,
          opt_target || selector.getFrame().contentDocument);
    } else {
      return util.getDomObjectsFromSelector(selector.obj, opt_target);
    }
  }
  try {
    var functionArr = [
      'getElementsByClassName',
      'getElementsByName',
      'getElementsByTagName',
      'getElementById',
      'getAttribute',
      'querySelectorAll'
    ]; //Try everything!

    for (var i = 0; i < functionArr.length; ++i) {
      if (target[functionArr[i]]) {
        var possibleObj = target[functionArr[i]](selector);
        if (possibleObj) {
          if (possibleObj.ownerDocument) {
            return [possibleObj];
          } else if (possibleObj.length != 0 && possibleObj[0].ownerDocument) {
            return possibleObj;
          }
        }
      }
    }
  }
  catch (err) { ++i; }
  return []; //return empty array if nothing is found
};

/**
 * filters out the invisible DOM objects in the array
 * not comprehensive check but so far
 * visibility check robustness is enough
 * @param {Array} array of object selectors to check if they are visible.
 * @return {Array} array of visible object selectors.
 */
util.whichOnesVisible = function(array) {
  var visible = new Array();
  for (var i = 0; i < array.length; ++i) {
    var objects = util.getDomObjectsFromSelector(array[i]);
    if (array[2] instanceof cvoxExt.speakableInIframe) {
    }
    for (var j = 0; j < objects.length; ++j) {
      if (util.isObjectVisible(objects[j])) {

        visible.push(array[i]);
        break;
      }
    }
  }
  return visible;
};

/**
 * filters out the non-loaded objects in the array
 * @param {Array} array of object selectors to check if they are loaded.
 * @return {Array} array of loaded object selectors.
 */
util.whichOnesLoad = function(array) {
  var loaded = new Array();
  for (var i = 0; i < array.length; ++i) {
    if (array[i]) {
      loaded.push(array[i]);
    }
  }
  return loaded;
};

/**
 * iframe aware object visible check
 * @param {HTMLElement} obj object to check visibility for.
 * @return {boolean} if the object is visible.
 */
util.isObjectVisible = function(obj) {
  if (!obj) { return false; }
  //get the css computed style from the window object resides in
  var css = obj.ownerDocument.defaultView.getComputedStyle(obj);
  if (css.visibility == 'hidden' || css.display == 'none') {
    return false;
  }
  //check parent node visibility
  if (obj.parentNode && obj.parentNode != obj.ownerDocument) {
    return util.isObjectVisible(obj.parentNode);
  }
  return true;
};

/**
 * an add all function which adds all the elements in the parameter to
 * the original array
 * @param {Array} arr1 the array to add all elements to.
 * @param {Array} arr2 the array to add all elements from.
 */
cvoxExt.util.arrayAddAll = function(arr1, arr2) {
  arr1 = arr1.concat(arr2);
};

/**-----------------------------------------------------------------------*/

/**
 * a namespace to load listeners and aliases for cvoxExt
 */
cvoxExt.loader = {};

/** loads cvoxExt listeners and alisases */
cvoxExt.loader.load = function() {
  cvoxExt.loadAliases();
  document.addEventListener('focus',
      cvoxExt.speakableManager.checkIfSpeakableFocused, true);
  document.addEventListener('keypress',
      cvoxExt.speakableManager.keyHandler, true);
  document.addEventListener('ready',
      cvoxExt.speakableManager.focusFirstElementOnLoad, true);
  document.addEventListener('load',
      cvoxExt.speakableManager.updateSpeakablesOnLoad, true);
};

/** json parser for speakable ***NOT WORKING ATM***
  * @param {String} jsonText JSON representation of text.
  */
cvoxExt.loader.parseSpeakable = function(jsonText) {
  var extensionFile = eval(jsonText);
  for (var i = 0; i < extensionFile.speakables.length; ++i) {
    var speakable = speakables[i];
    cvoxExt.speakableManager.addSpeakable(speakable);
  }
  for (var i = 0; i < extensionFile.frames.length; ++i) {
    var extension = frames[i];
    cvoxExt.iframeUtil.addFrame(frames[i].name,
        util.getFirstDomObjectFromSelector(frames[i]));
  }
};


/** loads cvoxExt aliases for convenience */
cvoxExt.loadAliases = function() {
  cvoxExt.whichOnesVisible = cvoxExt.util.whichOnesVisible;
  cvoxExt.addSpeakableKeyListener =
      cvoxExt.speakableManager.addSpeakableKeyListener;

  cvoxExt.addSpeakable = cvoxExt.speakableManager.addSpeakable;
  cvoxExt.updateSpeakables = cvoxExt.speakableManager.updateSpeakables;

};

/**------------------------------------------------------------------*/

/** a namespace for managing iframe awareness */
cvoxExt.iframeUtil = {}; //define subnamespace

iframeUtil = cvoxExt.iframeUtil;

/**-----------------------------------------------------------------*/

/**
 * extension object for each website
 * @constructor
 * @this {cvoxExt.extension}
 */
cvoxExt.extension = function() {
  this.init = function() {};
};

/** load new ChromeVox extension
 *  @param {cvoxExt.extension} extension extension to be loaded.
 */
cvoxExt.loadExtension = function(extension) {
  var loadExtensionCallback = function() {
    cvoxExt.loadExtension(extension);
  }
  if (!window.cvox) {
    setTimeout(loadExtensionCallback, 20);
    return;
  }
  extension.init();
  if (extension.load) {
    document.addEventListener('load', extension.load, true);
  }
  if (extension.ready) {
    document.addEventListener('ready', extension.ready, true);
  }
  if (extension.modified) {
    document.addEventListener('DOMSubtreeModified',
      extension.modified, true);
  }
};

cvoxExt.loader.load();
